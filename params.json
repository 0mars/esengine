{"name":"Esengine","tagline":"ElasticSearch ODM (Object Document Mapper) for Python - pip install esengine","body":"\r\n<img src=\"https://raw.githubusercontent.com/catholabs/esengine/master/octosearch.gif\" align=\"left\" width=\"192px\" height=\"132px\"/>\r\n<img align=\"left\" width=\"0\" height=\"192px\" hspace=\"10\"/>\r\n\r\n> **esengine** - The **E**lastic**s**earch **O**bject **D**ocument **M**apper\r\n\r\n[![PyPI](https://img.shields.io/pypi/v/esengine.svg)](https://pypi.python.org/pypi/esengine)\r\n[![versions](https://img.shields.io/pypi/pyversions/esengine.svg)](https://pypi.python.org/pypi/esengine)\r\n[![downloads](https://img.shields.io/pypi/dw/esengine.svg)](https://pypi.python.org/pypi/esengine)\r\n[![Travis CI](http://img.shields.io/travis/catholabs/esengine.svg)](https://travis-ci.org/catholabs/esengine)\r\n[![Coverage Status](http://img.shields.io/coveralls/catholabs/esengine.svg)](https://coveralls.io/r/catholabs/esengine)\r\n[![Code Health](https://landscape.io/github/catholabs/esengine/master/landscape.svg?style=flat)](https://landscape.io/github/catholabs/esengine/master)\r\n\r\n\r\n**esengine** is an ODM (**O**bject **D**ocument **M**apper) it maps Python classes in to **E**lastic**s**earch **index/doc_type** and **object instances()** in to Elasticsearch documents.\r\n\r\n<br><br>\r\n\r\n### Modeling\r\n\r\nOut of the box ESengine takes care only of the Modeling and CRUD operations including:\r\n\r\n- Index, DocType and Mapping specification \r\n- Fields and its types coercion\r\n- basic CRUD operations (Create, Read, Update, Delete)\r\n\r\n### Communication\r\nESengine does not communicate directly with ElasticSearch, it only creates the basic structure, \r\nTo communicate it relies on an ES client providing the transport methods (index, delete, update etc). \r\n\r\n### ES client\r\nESengine does not enforce the use of the official ElasticSearch client,\r\nbut you are encouraged to use it because it is well maintained and has the support to **bulk** operations. But you are free to use another client or create your own (useful for tests).\r\n\r\n### Querying the data\r\nESengine does not enforce or encourage you to use a DSL language for queries, out of the box you have to\r\nwrite the elasticsearch **payload** representation as a raw Python dictionary. However ESEngine comes with **utils.payload** helper module to help you building payloads in a less verbose and Pythonic way.\r\n\r\n### Why not elasticsearch_dsl?\r\n\r\nElasticSearch DSL is an excellent tool, a very nice effort by the maintainers of the official ES library, it is handy in most of the cases, but because it is built on top of operator overiding, sometimes leads to a **confuse query building**, sometimes it is better to write raw_queries or use a simpler payload builder having more control and visibility of what os being generated. \r\n\r\nElasticSearch_DSL as a high level abstraction promotes **Think only of Python objects, dont't worry about Elastic queries** while ESengine promotes **Know well the Elastic queries and then write them as Python objects**.\r\n\r\nElasticSearch_DSL is more powerful and more complete, tight more with ES specifications while ESEngine is simpler, lightweight shipping only the basics.\r\n\r\n### Project Stage\r\n\r\nIt is in beta-Release, working in production, but missing a lot of features, you can help using, testing,, discussing or coding!\r\n\r\n\r\n# Getting started\r\n\r\n## Installation\r\n\r\nESengine needs a client to communicate with E.S, you can use one of the following:\r\n\r\n- ElasticSearch-py (official)\r\n- Py-Elasticsearch (unofficial)\r\n- Create your own implementing the same api-protocol\r\n- Use the MockES provided as py.test fixture (only for tests)\r\n\r\nBecause of bulk operations you are recommendded to use\r\n**elasticsearch-py** (Official E.S Python library) so the instalation \r\ndepends on the version of elasticsearch you are using.\r\n\r\n\r\n### in short\r\n\r\nInstall the client and then install ESEngine\r\n\r\n- for 2.0 + use \"elasticsearch>=2.0.0,<3.0.0\"\r\n- for 1.0 + use \"elasticsearch>=1.0.0,<2.0.0\"\r\n- under 1.0 use \"elasticsearch<1.0.0\"\r\n\r\n\r\nFor the latest use:\r\n\r\n```sh\r\n$ pip install elasticsearch\r\n$ pip install esengine\r\n\r\n```\r\n\r\n### Or install them together\r\n\r\n#### Elasticsearch 2.x\r\n\r\n```bash\r\npip install esengine[es2]\r\n```\r\n\r\n#### Elasticsearch 1.x\r\n\r\n```bash\r\npip install esengine[es1]\r\n```\r\n\r\n#### Elasticsearch 0.90.x\r\n\r\n```bash\r\npip install esengine[es0]\r\n```\r\n\r\nThe above command will install esengine and the elasticsearch library specific for you ES version.\r\n\r\n# Usage\r\n\r\n```python\r\nfrom elasticsearch import ElasticSearch\r\nfrom esengine import Document, StringField\r\n```\r\n\r\n## Defining a document\r\n\r\n```python\r\nclass Person(Document):\r\n    # define _meta attributes\r\n    _doctype = \"person\"  # optional, it can be set after using \"having\" method\r\n    _index = \"universe\"  # optional, it can be set after using \"having\" method\r\n    _es = ElasticSearch(host='host', port=port)  # optional, it can be explicit passed to methods\r\n    \r\n    # define fields\r\n    name = StringField()\r\n    \r\n```\r\n\r\n> If you do not specify an \"id\" field, ESEngine will automatically add \"id\" as StringField. It is recommended that when specifying you use StringField for ids.\r\n\r\n## Fields\r\n\r\n### Base Fields\r\n\r\n```python\r\nname = StringField()\r\nage = IntegerField()\r\nweight = FloatField()\r\nfactor = LongField()\r\nactive = BooleanField()\r\nbirthday = DateField()\r\n```\r\n\r\n### Special Fields\r\n\r\n#### GeoPointField\r\n\r\nA field to hold GeoPoint with modes dict|array|string and its mappings\r\n\r\n```python\r\nclass Obj(Document):\r\n    location = GeoPointField(mode='dict')  # default\r\n    # An object representation with lat and lon explicitly named\r\n\r\nObj.init() # important to put the proper mapping for geo location\r\n\r\nobj = Obj()\r\n\r\nobj.location = {\"lat\": 40.722, \"lon\": -73.989}}\r\n\r\nclass Obj(Document):\r\n    location = GeoPointField(mode='string')\r\n    # A string representation, with \"lat,lon\"\r\n\r\nobj.location = \"40.715, -74.011\"\r\n\r\nclass Obj(Document):\r\n    location = GeoPointField(mode='array')\r\n    # An array representation with [lon,lat].\r\n\r\nobj.location = [-73.983, 40.719]\r\n```\r\n\r\n#### ObjectField\r\n\r\nA field to hold nested one-dimension objects, schema-less or with properties validation.\r\n\r\n```python\r\n# accepts only dictionaries having strct \"street\" and \"number\" keys\r\naddress = ObjectField(properties={\"street\": \"string\", \"number\": \"integer\"})\r\n\r\n# Accepts any Python dictionary\r\nextravalues = ObjectField() \r\n```\r\n\r\n#### ArrayField\r\n\r\nA Field to hold arrays (python lists)\r\n\r\nIn the base, any field can accept **multi** parameter\r\n\r\n```python\r\ncolors = StringField(multi=True)   # accepts [\"blue\", \"green\", \"yellow\", ....]\r\n```\r\n\r\nBut sometimes (specially for nested objects) it is better to be explicit, and also it generates a better mapping\r\n\r\n```python\r\n# accepts an array of strings [\"blue\", \"green\", \"yellow\", ....]\r\ncolors = ArrayField(StringField()) \r\n```\r\n\r\nIt is available for any other field\r\n\r\n```\r\nlocations = ArrayField(GeoPointField())\r\nnumbers = ArrayField(IntegerField())\r\nfractions = ArrayField(FloatField())\r\naddresses = ArrayField(ObjectField(properties={\"street\": \"string\", \"number\": \"integer\"}))\r\nlist_of_lists_of_strings = ArrayField(ArrayField(StringField()))\r\n```\r\n\r\n## Indexing\r\n\r\n```python\r\nperson = Person(id=1234, name=\"Gonzo\")\r\nperson.save()  # or pass .save(es=es_client_instance) if not specified in model \r\n```\r\n\r\n## Getting by id\r\n\r\n```python\r\nPerson.get(id=1234)\r\n```\r\n\r\n## filtering by IDS\r\n\r\n```python\r\nids = [1234, 5678, 9101]\r\npower_trio = Person.filter(ids=ids)\r\n```\r\n\r\n\r\n## filtering by fields\r\n\r\n```python\r\nPerson.filter(name=\"Gonzo\")\r\n```\r\n\r\n## Searching\r\n\r\nESengine does not try to create abstraction for query building, \r\nby default ESengine only implements search transport receiving a raw ES query \r\nin form of a Python dictionary.\r\n\r\n```python\r\nquery = {\r\n    \"query\": {\r\n        \"filtered\": {\r\n            \"query\": {\r\n                \"match_all\": {}\r\n            },\r\n            \"filter\": {\r\n                \"ids\": {\r\n                    \"values\": [1, 2]\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nPerson.search(query, size=10)\r\n```\r\n\r\n## Getting all documents (match_all)\r\n\r\n```python\r\nPerson.all()\r\n\r\n# with more arguments\r\n\r\nPerson.all(size=20)\r\n\r\n```\r\n\r\n\r\n## Counting\r\n\r\n```python\r\nPerson.count(name='Gonzo')\r\n```\r\n\r\n## Updating\r\n\r\n###  A single document\r\n\r\nA single document can be updated simply using the **.save()** method\r\n\r\n```python\r\n\r\nperson = Person.get(id=1234)\r\nperson.name = \"Another Name\"\r\nperson.save()\r\n\r\n```\r\n\r\n### Updating a Resultset\r\n\r\nThe Document methods **.get**, **.filter** and **.search** will return an instance\r\nof **ResultSet** object. This object is an Iterator containing the **hits** reached by \r\nthe filtering or search process and exposes some CRUD methods[ **update**, **delete** and **reload** ]\r\nto deal with its results.\r\n\r\n\r\n```python\r\npeople = Person.filter(field='value')\r\npeople.update(another_field='another_value')\r\n```\r\n\r\n> When updating documents sometimes you need the changes done in the E.S index reflected in the objects \r\nof the **ResultSet** iterator, so you can use **.reload** method to perform that action.\r\n\r\n\r\n### The use of **reload** method\r\n \r\n```python\r\npeople = Person.filter(field='value')\r\nprint people\r\n... <Resultset: [{'field': 'value', 'another_field': None}, \r\n                 {'field': 'value', 'another_field': None}]>\r\n\r\n# Updating another field on both instances\r\npeople.update(another_field='another_value')\r\nprint people\r\n... <Resultset: [{'field': 'value', 'another_field': None}, {'field': 'value', 'another_field': None}]>\r\n\r\n# Note that in E.S index the values weres changed but the current ResultSet is not updated by defaul\r\n# you have to fire an update\r\npeople.reload()\r\n\r\nprint people\r\n... <Resultset: [{'field': 'value', 'another_field': 'another_value'},\r\n                 {'field': 'value', 'another_field': 'another_value'}]>\r\n\r\n\r\n```\r\n\r\n### Deleting documents\r\n\r\n\r\n#### A ResultSet\r\n\r\n```python\r\npeople = Person.all()\r\npeople.delete()\r\n```\r\n\r\n#### A single document\r\n\r\n```python\r\nPerson.get(id=123).delete()\r\n```\r\n\r\n## Bulk operations\r\n\r\nESEngine takes advantage of elasticsearch-py helpers for bulk actions, \r\nthe **ResultSet** object uses **bulk** melhod to **update** and **delete** documents.\r\n\r\nBut you can use it in a explicit way using Document's **update_all**, **save__all** and **delete_all** methods.\r\n\r\n#### Lets create a bunch of document instances\r\n\r\n\r\n```python\r\ntop_5_racing_bikers = []\r\n\r\nfor name in ['Eddy Merckx', \r\n             'Bernard Hinault', \r\n             'Jacques Anquetil', \r\n             'Sean Kelly', \r\n             'Lance Armstrong']:\r\n     top_5_racing_bikers.append(Person(name=name))\r\n```\r\n\r\n#### Save it all \r\n\r\n```python\r\nPerson.save_all(top_5_racing_bikers)\r\n```\r\n\r\n#### Using the **create** shortcut\r\n\r\nThe above could be achieved using **create** shortcut\r\n\r\n\r\n##### A single\r\n\r\n```python\r\nPerson.create(name='Eddy Merckx', active=False)\r\n```\r\n\r\n> Create will return the instance of the indexed Document\r\n\r\n##### All using list comprehension\r\n\r\n```python\r\ntop_5_racing_bikers = [\r\n    Person.create(name=name, active=False)\r\n    for name in ['Eddy Merckx', \r\n                 'Bernard Hinault', \r\n                 'Jacques Anquetil', \r\n                 'Sean Kelly', \r\n                 'Lance Armstrong']\r\n]\r\n\r\n```\r\n> NOTE: **.create** method will automatically save the document to the index, and\r\nwill not raise an error if there is a document with the same ID (if specified), it will update it acting as upsert.\r\n\r\n#### Updating all\r\n\r\nTurning the field **active** to **True** for all documents\r\n\r\n```python\r\nPerson.update_all(top_5_racing_bikes, active=True)\r\n```\r\n\r\n#### Deleting all\r\n\r\n```python\r\nPerson.delete_all(top_5_racing_bikes)\r\n```\r\n\r\n\r\n#### Chunck size\r\n\r\nchunk_size is number of docs in one chunk sent to ES (default: 500)\r\nyou can change using **meta** argument.\r\n\r\n```python\r\nPerson.update_all(\r\n    top_5_racing_bikes, # the documents\r\n    active=True,  # values to be changed\r\n    meta={'chunk_size': 200}  # meta data passed to **bulk** operation    \r\n)\r\n```\r\n\r\n#### Utilities\r\n\r\n#### Mapping and Mapping migrations\r\n\r\nESEngine does not saves mappings automatically, but it offers an utility to generate and save mappings on demand\r\nYou can create a cron job to refresh mappings once a day or run it every time your model changes\r\n\r\n##### Using the document\r\n\r\n```python\r\nclass Person(Document):\r\n    # define _meta attributes\r\n    _doctype = \"person\"  # optional, it can be set after using \"having\" method\r\n    _index = \"universe\"  # optional, it can be set after using \"having\" method\r\n    _es = ElasticSearch(host='host', port=port)  # optional, it can be explicit passed to methods\r\n    \r\n    # define fields\r\n    name = StringField()\r\n    \r\n```\r\n\r\n##### You can use **init** class method to initialize/update mappings, settings and analyzers    \r\n\r\n```\r\nPerson.init()  # if not defined in model, pass an **es=es_client** here\r\n```\r\n\r\n> Include above in your the last line of your model files or cron jobs or migration scripts\r\n\r\n#### Validators\r\n\r\n##### Field Validator\r\n\r\nTo validate each field separately you can set a list of validators, each \r\nvalidator is a callable receiving field_name and value as arguments and\r\nshould return None to be valid. If raise or return the data will be invalidated\r\n\r\n```python\r\nfrom esengine.exceptions import ValidationError\r\n\r\ndef category_validator(field_name, value):\r\n    # check if value is in valid categories\r\n    if value not in [\"primary\", \"secondary\", ...]:\r\n        raise ValidationError(\"Invalid category!!!\")\r\n    \r\nclass Obj(Document):\r\n    category = StringField(validators=[category_validator])\r\n\r\nobj = Obj()\r\nobj.category = \"another\"\r\nobj.save()\r\nTraceback: ValidationError(....)\r\n\r\n```\r\n\r\n##### Document Validator\r\n\r\nTo validate the whole document you can set a list of validators, each \r\nvalidator is a callable receiving the document instance and\r\nshould return None to be valid. If raise or return the data will be invalidated\r\n\r\n```python\r\nfrom esengine.exceptions import ValidationError\r\n\r\ndef if_city_state_is_required(obj):\r\n    if obj.city and not obj.state:\r\n        raise ValidationError(\"If city is defined you should define state\")\r\n        \r\nclass Obj(Document):\r\n    _validators = [if_city_state_is_required]\r\n    \r\n    city = StringField()\r\n    state = StringField()\r\n\r\nobj = Obj()\r\nobj.city = \"Sao Paulo\"\r\nobj.save()\r\nTraceback: ValidationError(....)\r\n\r\n```\r\n\r\n#### Refreshing\r\n\r\nSometimes you need to force indices-shards refresh for testing, you can use\r\n\r\n```python\r\n# Will refresh all indices\r\nDocument.refresh()\r\n```\r\n\r\n#### Payload builder\r\n\r\nSometimes queries turns in to complex and verbose data structures, to help you\r\n(use with moderation) you can use Payload utils to build queries.\r\n\r\n\r\n###### Example using a raw query:\r\n\r\n```python\r\nquery = {\r\n    \"query\": {\r\n        \"filtered\": {\r\n            \"query\": {\r\n                \"match_all\": {}\r\n            },\r\n            \"filter\": {\r\n                \"ids\": {\r\n                    \"values\": [1, 2]\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nPerson.search(query=query, size=10)\r\n```\r\n\r\n###### Same example using payload utils\r\n\r\n```python\r\nfrom esengine import Payload, Query, Filter\r\npayload = Payload(query=Query.filtered(query=Query.match_all(), filter=Filter.ids([1, 2])))\r\nPerson.search(payload, size=10)\r\n```\r\n\r\n> Payload utils exposes Payload, Query, Filter, Aggregate, Suggesters\r\n\r\nYou can also set model on payload initialization to create a more complete payload definition\r\n\r\n```python\r\nfrom esengine import Payload, Query, Filter\r\npayload = Payload(\r\n    model=Person,\r\n    query=Query.filtered(query=Query.match_all(), filter=Filter.ids([1, 2]))\r\n    sort={\"name\": {\"order\": \"desc\"}},\r\n    size=10\r\n)\r\npayload.search()\r\n```\r\n\r\n###### More examples\r\n\r\nYou can use Payload, Query or Filter direct in search\r\n\r\n```python\r\nfrom esengine import Payload, Query, Filter\r\n\r\nPerson.search(Payload(query=Query.match_all()))\r\n\r\nPerson.search(Query.bool(must=[Query.match(\"name\", \"Gonzo\")]))\r\n\r\nPerson.search(Query.match_all())\r\n\r\nPerson.search(Filter.ids([1, 2, 3]))\r\n\r\n```\r\n\r\n###### chaining\r\n\r\nPayload object is chainable so you can do:\r\n```python\r\npayload = Payload(query=query).size(10).sort(\"field\", order=\"desc\")\r\nDocument.search(payload) \r\n# or the equivalent\r\npayload.search(Document)\r\n```\r\n\r\n\r\n#### Pagination\r\n\r\nYou can paginate a payload, lets say you have indexed 500 documents under 'test' category and now you need to retrieve 50 per page.\r\n\r\n> Result will be included in **pagination.items** \r\n\r\n```python\r\nfrom esengine import Payload, Filter\r\nfrom models import Doc\r\n\r\npayload = Payload(Doc, filter=Filter.term('category', 'test'))\r\n\r\n# Total documents\r\npayload.count()\r\n500\r\n\r\n# Paginate it\r\ncurrent_page = 1  # you have to increase it on each pagination\r\npagination = payload.paginate(page=current_page, per_page=50)\r\n\r\npagination.total\r\n500\r\n\r\npagination.pages\r\n10\r\n\r\npagination.has_prev\r\nFalse\r\n\r\npagination.has_next\r\nTrue\r\n\r\npagination.next_num\r\n2\r\n\r\nlen(pagination.items)\r\n50\r\n\r\nfor item in pagination.items:\r\n    # do something with item\r\n\r\n# Turn the page\r\n\r\ncurrent_page += 1\r\npagination = payload.paginate(page=current_page, per_page=50)\r\npagination.page\r\n2\r\npagination.has_prev\r\nTrue\r\n\r\n# Another option to move pages\r\n\r\npagination  = pagination.next_page()\r\npagination.page\r\n3\r\n\r\npagination = pagination.prev_page()\r\npagination.page\r\n2\r\n\r\n# Turn the page in place\r\n\r\npagination.backward()\r\npagination.page\r\n1\r\n\r\npagination.forward()\r\npagination.page\r\n2\r\n```\r\n\r\n##### Create a paginator in Jinja template\r\n\r\nSo you want to create buttons for pagination in your jinja template\r\n\r\n```html+jinja\r\n{% macro render_pagination(pagination, endpoint) %}\r\n  <div class=pagination>\r\n  {%- for page in pagination.iter_pages() %}\r\n    {% if page %}\r\n      {% if page != pagination.page %}\r\n        <a href=\"{{ url_for(endpoint, page=page) }}\">{{ page }}</a>\r\n      {% else %}\r\n        <strong>{{ page }}</strong>\r\n      {% endif %}\r\n    {% else %}\r\n      <span class=ellipsis>…</span>\r\n    {% endif %}\r\n  {%- endfor %}\r\n  </div>\r\n{% endmacro %}\r\n```\r\n\r\n\r\n# Contribute\r\n\r\nESEngine is OpenSource! join us!\r\n<a href=\"http://smallactsmanifesto.org\" title=\"Small Acts Manifesto\"><img src=\"http://smallactsmanifesto.org/static/images/smallacts-badge-80x15-blue.png\" style=\"border: none;\" alt=\"Small Acts Manifesto\" /></a>\r\n\r\n**MADE WITH #LOVE AND #PYTHON (which is the same) AT [CathoLabs](http://catholabs.com)**  \r\n\r\n![catholabs](http://catholabs.com/_themes/catholabs/img/logo_black.png)\r\n","google":"UA-72359632-1","note":"Don't delete this file! It's used internally to help with page regeneration."}