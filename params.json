{"name":"Esengine","tagline":"A basic ODM (Object Document Mapper) for Elasticsearch based on MongoEngine.","body":"[![Travis CI](http://img.shields.io/travis/catholabs/esengine.svg)](https://travis-ci.org/catholabs/esengine)\r\n[![Coverage Status](http://img.shields.io/coveralls/catholabs/esengine.svg)](https://coveralls.io/r/catholabs/esengine)\r\n[![Code Health](https://landscape.io/github/catholabs/esengine/master/landscape.svg?style=flat)](https://landscape.io/github/catholabs/esengine/master)\r\n<a href=\"http://smallactsmanifesto.org\" title=\"Small Acts Manifesto\"><img src=\"http://smallactsmanifesto.org/static/images/smallacts-badge-80x15-blue.png\" style=\"border: none;\" alt=\"Small Acts Manifesto\" /></a>\r\n\r\n# ESEngine - ElasticSearch ODM \r\n## (Object Document Mapper) inspired by MongoEngine\r\n \r\n<p align=\"left\" style=\"float:left\" >\r\n    <img src=\"https://github.com/catholabs/esengine/raw/master/octosearch.gif\" alt=\"EsEngine\" width=\"300\" />\r\n</p>\r\n\r\n\r\n# install\r\n\r\nESengine depends on elasticsearch-py (Official E.S Python library) so the instalation \r\ndepends on the version of elasticsearch you are using.\r\n\r\n\r\n## Elasticsearch 2.x\r\n\r\n```bash\r\npip install esengine[es2]\r\n```\r\n\r\n## Elasticsearch 1.x\r\n\r\n```bash\r\npip install esengine[es1]\r\n```\r\n\r\n## Elasticsearch 0.90.x\r\n\r\n```bash\r\npip install esengine[es0]\r\n```\r\n\r\nThe above command will install esengine and the elasticsearch library specific for you ES version.\r\n\r\n\r\n> Alternatively you can install elasticsearch library before esengine\r\n\r\npip install ``<version-specific-es>`` \r\n\r\n- for 2.0 + use \"elasticsearch>=2.0.0,<3.0.0\"\r\n- for 1.0 + use \"elasticsearch>=1.0.0,<2.0.0\"\r\n- under 1.0 use \"elasticsearch<1.0.0\"\r\n\r\nThen install esengine\r\n\r\n```bash\r\npip install esengine\r\n```\r\n\r\n# Getting started\r\n\r\n```python\r\nfrom elasticsearch import ElasticSearch\r\nfrom esengine import Document, StringField\r\n\r\nes = ElasticSearch(host='host', port=port)\r\n```\r\n\r\n# Defining a document\r\n\r\n```python\r\nclass Person(Document):\r\n    _doctype = \"person\"\r\n    _index = \"universe\"\r\n    \r\n    name = StringField()\r\n    \r\n```\r\n\r\n> If you do not specify an \"id\" field, ESEngine will automatically add \"id\" as StringField. It is recommended that when specifying you use StringField for ids.\r\n\r\n# Indexing\r\n\r\n```python\r\nperson = Person(id=1234, name=\"Gonzo\")\r\nperson.save(es=es)\r\n```\r\n\r\n# Getting by id\r\n\r\n```python\r\nPerson.get(id=1234, es=es)\r\n```\r\n\r\n# filtering by IDS\r\n\r\n```python\r\nids = [1234, 5678, 9101]\r\npower_trio = Person.filter(ids=ids)\r\n```\r\n\r\n\r\n# filtering by fields\r\n\r\n```python\r\nPerson.filter(name=\"Gonzo\", es=es)\r\n```\r\n\r\n# Searching\r\n\r\nESengine does not try to create abstraction for query building, \r\nby default ESengine only implements search transport receiving a raw ES query \r\nin form of a Python dictionary.\r\n\r\n```python\r\nquery = {\r\n    \"query\": {\r\n        \"filtered\": {\r\n            \"query\": {\r\n                \"match_all\": {}\r\n            },\r\n            \"filter\": {\r\n                \"ids\": {\r\n                    \"values\": list(ids)\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nPerson.search(query, size=10, es=es)\r\n```\r\n\r\n# Default connection\r\n\r\nBy default ES engine does not try to implicit create a connection for you, \r\nbut you can easily achieve this overwriting the **get_es** method and returning a \r\ndefault connection or using any kind of technique as RoundRobin or Mocking for tests\r\nAlso you can set the **_es** attribute pointing to a function generating the connection client\r\nor the client instance as the following example:\r\n\r\n```python\r\n\r\nfrom elasticsearch import ElasticSearch\r\nfrom esengine import Document, StringField\r\nfrom esengine.utils import validate_client\r\n\r\n\r\nclass Person(Document):\r\n    _doctype = \"person\"\r\n    _index = \"universe\"\r\n    _es = Elasticsearch(host='10.0.0.0')\r\n    \r\n    name = StringField()\r\n    \r\n```\r\n        \r\n# Now you can use the document transport methods ommiting ES instance\r\n\r\n\r\n```python\r\nperson = Person(id=1234, name=\"Gonzo\")\r\nperson.save()\r\n         \r\nPerson.get(id=1234)\r\n\r\nPerson.filter(name=\"Gonzo\")\r\n```\r\n\r\n\r\n# Updating\r\n\r\n##  A single document\r\n\r\nA single document can be updated simply using the **.save()** method\r\n\r\n```python\r\n\r\nperson = Person.get(id=1234)\r\nperson.name = \"Another Name\"\r\nperson.save()\r\n\r\n```\r\n\r\n## Updating a Resultset\r\n\r\nThe Document methods **.get**, **.filter** and **.search** will return an instance\r\nof **ResultSet** object. This object is an Iterator containing the **hits** reached by \r\nthe filtering or search process and exposes some CRUD methods[ **update**, **delete** and **reload** ]\r\nto deal with its results.\r\n\r\n\r\n```python\r\npeople = Person.filter(field='value')\r\npeople.update(another_field='another_value')\r\n```\r\n\r\n> When updating documents sometimes you need the changes done in the E.S index reflected in the objects \r\nof the **ResultSet** iterator, so you can use **.reload** method to perform that action.\r\n\r\n\r\n## The use of **reload** method\r\n \r\n```python\r\npeople = Person.filter(field='value')\r\nprint people\r\n... <Resultset: [{'field': 'value', 'another_field': None}, \r\n                 {'field': 'value', 'another_field': None}]>\r\n\r\n# Updating another field on both instances\r\npeople.update(another_field='another_value')\r\nprint people\r\n... <Resultset: [{'field': 'value', 'another_field': None}, {'field': 'value', 'another_field': None}]>\r\n\r\n# Note that in E.S index the values weres changed but the current ResultSet is not updated by defaul\r\n# you have to fire an update\r\npeople.reload()\r\n\r\nprint people\r\n... <Resultset: [{'field': 'value', 'another_field': 'another_value'},\r\n                 {'field': 'value', 'another_field': 'another_value'}]>\r\n\r\n\r\n```\r\n\r\n## Deleting documents\r\n\r\n\r\n### A ResultSet\r\n\r\n```python\r\npeople = Person.all()\r\npeople.delete()\r\n```\r\n\r\n### A single document\r\n\r\n```python\r\nPerson.get(id=123).delete()\r\n```\r\n\r\n# Bulk operations\r\n\r\nESEngine takes advantage of elasticsearch-py helpers for bulk actions, \r\nthe **ResultSet** object uses **bulk** melhod to **update** and **delete** documents.\r\n\r\nBut you can use it in a explicit way using Document's **update_all**, **save__all** and **delete_all** methods.\r\n\r\n### Lets create a bunch of document instances\r\n\r\n\r\n```python\r\ntop_5_racing_bikers = []\r\n\r\nfor name in ['Eddy Merckx', \r\n             'Bernard Hinault', \r\n             'Jacques Anquetil', \r\n             'Sean Kelly', \r\n             'Lance Armstrong']:\r\n     top_5_racing_bikers.append(Person(name=name))\r\n```\r\n\r\n### Save it all \r\n\r\n```python\r\nPerson.save_all(top_5_racing_bikers)\r\n```\r\n\r\n### Using the **create** shortcut\r\n\r\nThe above could be achieved using **create** shortcut\r\n\r\n\r\n#### A single\r\n\r\n```python\r\nPerson.create(name='Eddy Merckx', active=False)\r\n```\r\n\r\n> Create will return the instance of the indexed Document\r\n\r\n#### All using list comprehension\r\n\r\n```python\r\ntop_5_racing_bikers = [\r\n    Person.create(name=name, active=False)\r\n    for name in ['Eddy Merckx', \r\n                 'Bernard Hinault', \r\n                 'Jacques Anquetil', \r\n                 'Sean Kelly', \r\n                 'Lance Armstrong']\r\n]\r\n\r\n```\r\n> NOTE: **.create** method will automatically save the document to the index, and\r\nwill not raise an error if there is a document with the same ID (if specified), it will update it acting as upsert.\r\n\r\n### Updating all\r\n\r\nTurning the field **active** to **True** for all documents\r\n\r\n```python\r\nPerson.update_all(top_5_racing_bikes, active=True)\r\n```\r\n\r\n### Deleting all\r\n\r\n```python\r\nPerson.delete_all(top_5_racing_bikes)\r\n```\r\n\r\n\r\n### Chunck size\r\n\r\nchunk_size is number of docs in one chunk sent to ES (default: 500)\r\nyou can change using **meta** argument.\r\n\r\n```python\r\nPerson.update_all(\r\n    top_5_racing_bikes, # the documents\r\n    active=True,  # values to be changed\r\n    metal={'chunk_size': 200}  # meta data passed to **bulk** operation    \r\n)\r\n```\r\n\r\n# Contribute\r\n\r\nESEngine is OpenSource! join us!","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}